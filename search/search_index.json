{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-altimate-django-library","title":"Welcome to Altimate Django Library","text":"<p>Altimate Django is a powerful library designed to help you maintain consistent data and prevent common issues in your Django projects. By analyzing your models' fields, this library identifies potential data inconsistencies, performance issues, and other pitfalls that could negatively impact your application. The tool is designed to help developers identify and prevent potential issues in their Django models. We have classified the checks implemented in the tool according to the types of issues they can catch: data loss, data corruption, data inconsistency, and other. Understanding these categories will help developers better address the issues detected by the tool and improve the overall quality and integrity of their Django applications.</p>"},{"location":"#data-loss","title":"Data Loss","text":"<ul> <li>ReverseCascade: Ensures that a ForeignKey or OneToOneField is not set to CASCADE delete and allows null values, preventing unintended data loss when related records are deleted.</li> <li>CascadeForFKOneToOne: Checks if a ForeignKey or OneToOneField uses CASCADE delete and does not allow null values, preventing unintended data loss when related records are deleted.</li> <li>InappropriateCascade: Verifies that CASCADE is not being used inappropriately on ForeignKey fields, preventing unintended data loss when related records are deleted.</li> </ul>"},{"location":"#data-corruption","title":"Data Corruption","text":"<ul> <li>MissingDefault: Ensures that fields with null=False have a default value specified to avoid potential data corruption.</li> <li>UniqueWithoutIndex: Verifies that unique constraints are created with indexes to prevent data corruption due to slow queries.</li> </ul>"},{"location":"#data-inconsistency","title":"Data Inconsistency","text":"<ul> <li>MinMaxValidator: Checks if MinValueValidator and MaxValueValidator are applied to numeric fields, ensuring data consistency and preventing out-of-range values.</li> <li>ExcessiveNulls: Ensures that fields are not unnecessarily set to allow null values, preventing data inconsistency.</li> <li>NullableUniqueFields: Checks if unique fields are set to allow null values, preventing data inconsistency.</li> <li>UnboundedAutoIncrementPK: Verifies that models with auto-incrementing primary keys have a maximum value set, preventing data inconsistency due to running out of primary key values.</li> <li>CascadeOnForeignKey: Ensures that ForeignKey fields have appropriate on_delete behavior to maintain data consistency.</li> <li>LargeCharField: Verifies that CharField maximum lengths are set to reasonable values to maintain data consistency.</li> <li>ExcessiveBlanks: Ensures that fields are not unnecessarily set to allow blank values, preventing data inconsistency.</li> </ul>"},{"location":"#other","title":"Other","text":"<ul> <li>ReservedSQLKeywords: Verifies that model and field names do not use reserved SQL keywords, preventing potential naming conflicts and issues.</li> <li>ForeignKeyNaming: Ensures that the naming convention for ForeignKey fields follows the format: \"{related_model_name.lower()}_id\".</li> <li>MissingHelpText: Checks if fields have help_text specified, improving user experience and reducing confusion.</li> </ul>"},{"location":"#real-life-examples","title":"Real-life Examples","text":"<p>Imagine working on a project that requires strict data validation and performance optimization. With Django Model Field Checks, you can catch issues early, improve code quality, and ensure your project maintains high standards.</p>"},{"location":"#example-1-preventing-data-loss","title":"Example 1: Preventing Data Loss","text":"<p>Suppose you have a <code>UserProfile</code> model with a <code>user</code> field, which is a ForeignKey to the built-in <code>User</code> model. When a user is deleted, you want to avoid accidentally removing their profile data. The <code>ReverseCascade</code> check can identify this issue and recommend allowing <code>null</code> values or using a different delete rule to prevent unintended data loss:</p> <pre><code>from django.db import models\nfrom django.contrib.auth.models import User\nclass UserProfile(models.Model):\nuser = models.ForeignKey(User, on_delete=models.CASCADE)  # Potential data loss!\n</code></pre>"},{"location":"#example-2-avoiding-sql-keyword-conflicts","title":"Example 2: Avoiding SQL Keyword Conflicts","text":"<p>When naming your model fields, you might unintentionally use a reserved SQL keyword, leading to unexpected behavior or SQL syntax errors. The ReservedSQLKeywords check detects fields that use reserved SQL keywords and suggests renaming them:</p> <pre><code>from django.db import models\nclass MyModel(models.Model):\nselect = models.CharField(max_length=100)  # 'select' is a reserved SQL keyword!\n</code></pre>"},{"location":"#example-3-ensuring-data-consistency","title":"Example 3: Ensuring Data Consistency","text":"<p>Numeric fields in your models should have minimum and maximum value validators to ensure data consistency and prevent out-of-range values. The MinMaxValidator check identifies fields that lack these validators and recommends adding them:</p> <pre><code>from django.db import models\nclass Product(models.Model):\nprice = models.DecimalField(max_digits=10, decimal_places=2)  # No MinValueValidator or MaxValueValidator!\n</code></pre>"},{"location":"#sample-output","title":"Sample Output","text":""},{"location":"installation/","title":"Installation and Usage","text":""},{"location":"installation/#installation-and-usage","title":"Installation and Usage","text":"<p>Welcome to the installation and usage guide for the <code>altimate-django</code> library! This powerful library helps you maintain consistent data and prevent common issues in your Django projects. In this guide, we'll show you how to install the library, add it to your Django project, and run the <code>altimate</code> command to trigger the checks.</p>"},{"location":"installation/#installation","title":"Installation","text":"<p>To install <code>altimate-django</code>, simply use <code>pip</code> to install the package from PyPI:</p> <pre><code>pip install altimate-django\n</code></pre>"},{"location":"installation/#setup","title":"Setup","text":"<p>Once you've installed the package, you need to add it to the INSTALLED_APPS section in your Django project's settings:</p> <pre><code># settings.py\nINSTALLED_APPS = [\n# ...\n'altimate_django',\n# ...\n]\n</code></pre>"},{"location":"installation/#running-the-checks","title":"Running the Checks","text":"<p>To run the field checks provided by altimate_django, use Django's manage.py script and call the altimate command:</p> <pre><code>python manage.py altimate\n</code></pre> <p>This command will analyze your models' fields and report any potential issues or inconsistencies, along with actionable recommendations to improve your code quality and data consistency.</p>"},{"location":"installation/#happy-coding","title":"Happy Coding!","text":"<p>With altimate_django installed and configured, you're ready to enhance the robustness, efficiency, and consistency of your Django applications. Enjoy building high-quality projects and be confident that your models stand the test of time!</p> <p>Don't forget to check the other pages in this documentation for more information on each specific check provided by the library.</p>"},{"location":"checks/cascade_for_fk_one_to_one/","title":"Cascade for Foreign Key & One-to-One","text":""},{"location":"checks/cascade_for_fk_one_to_one/#cascade-for-foreignkey-and-onetoonefield","title":"Cascade for ForeignKey and OneToOneField","text":""},{"location":"checks/cascade_for_fk_one_to_one/#description","title":"Description","text":"<p>This check ensures that <code>ForeignKey</code> and <code>OneToOneField</code> fields are using the <code>CASCADE</code> option for the <code>on_delete</code> parameter.</p>"},{"location":"checks/cascade_for_fk_one_to_one/#rationale","title":"Rationale","text":"<p>Using <code>CASCADE</code> for the <code>on_delete</code> parameter in <code>ForeignKey</code> and <code>OneToOneField</code> fields ensures that related objects are automatically deleted when the referenced object is deleted, helping maintain database integrity. Other options, like <code>PROTECT</code>, <code>SET_NULL</code>, or <code>SET_DEFAULT</code>, may be appropriate in some cases, but using <code>CASCADE</code> is a safer default choice.</p>"},{"location":"checks/cascade_for_fk_one_to_one/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass Author(models.Model):\nname = models.CharField(max_length=100)\nclass Book(models.Model):\ntitle = models.CharField(max_length=100)\nauthor = models.ForeignKey(Author, on_delete=models.PROTECT)\n</code></pre> <p>The author field is a ForeignKey field, but it's not using the CASCADE option for on_delete. The check would detect this and recommend changing the on_delete option to models.CASCADE:</p> <pre><code>author = models.ForeignKey(Author, on_delete=models.CASCADE)\n</code></pre> <p>However, if you have a specific reason for not using CASCADE, you should evaluate the impact on your application's data integrity and adjust the check accordingly.</p>"},{"location":"checks/cascade_on_foreign_key/","title":"Cascade for Foreign Key","text":""},{"location":"checks/cascade_on_foreign_key/#cascade-on-foreignkey","title":"Cascade on ForeignKey","text":""},{"location":"checks/cascade_on_foreign_key/#description","title":"Description","text":"<p>This check ensures that <code>ForeignKey</code> fields are not using the <code>CASCADE</code> option for the <code>on_delete</code> parameter and raises a warning about potential data loss.</p>"},{"location":"checks/cascade_on_foreign_key/#rationale","title":"Rationale","text":"<p>Using <code>CASCADE</code> for the <code>on_delete</code> parameter in <code>ForeignKey</code> fields can lead to unexpected data loss when the referenced object is deleted. While it may be appropriate in some cases, other options like <code>SET_NULL</code> or <code>PROTECT</code> can be safer alternatives depending on the application's requirements.</p>"},{"location":"checks/cascade_on_foreign_key/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass Author(models.Model):\nname = models.CharField(max_length=100)\nclass Book(models.Model):\ntitle = models.CharField(max_length=100)\nauthor = models.ForeignKey(Author, on_delete=models.CASCADE)\n</code></pre> <p>The author field is a ForeignKey field and is using the CASCADE option for on_delete. The check would detect this and recommend considering alternative options:</p> <pre><code>author = models.ForeignKey(Author, on_delete=models.SET_NULL, null=True)\n# or\nauthor = models.ForeignKey(Author, on_delete=models.PROTECT)\n</code></pre> <p>Evaluate the impact of using CASCADE on your application's data integrity and choose the appropriate option based on your specific use case.</p>"},{"location":"checks/excessive_blanks/","title":"Excessive Blanks","text":""},{"location":"checks/excessive_blanks/#excessive-blanks","title":"Excessive Blanks","text":""},{"location":"checks/excessive_blanks/#description","title":"Description","text":"<p>This check identifies if the <code>blank</code> attribute of fields is excessively set to <code>True</code>, which may cause issues with data consistency and validation.</p>"},{"location":"checks/excessive_blanks/#rationale","title":"Rationale","text":"<p>Allowing blank values for fields that are not <code>ManyToManyField</code>, <code>ManyToManyRel</code>, or <code>ManyToOneRel</code> can lead to inconsistencies in data and validation issues. By setting <code>blank</code> to <code>True</code>, you are allowing the field to be empty in forms, which might not be suitable for all use cases.</p>"},{"location":"checks/excessive_blanks/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass User(models.Model):\nusername = models.CharField(max_length=100, blank=True)\nemail = models.EmailField(blank=True)\nage = models.PositiveIntegerField(blank=True)\n</code></pre> <p>The username, email, and age fields have blank=True, which may lead to data inconsistency and validation issues. The check would detect this and recommend reviewing the use of blank=True in these fields:</p> <pre><code>username = models.CharField(max_length=100)\nemail = models.EmailField()\nage = models.PositiveIntegerField(null=True, blank=True)\n</code></pre> <p>In this example, we removed the blank=True attribute from the username and email fields to enforce non-empty values, while allowing the age field to be empty by setting both null=True and blank=True.</p> <p>Review the use of blank=True in your model fields and determine whether it is necessary or if it should be removed.</p>"},{"location":"checks/excessive_nulls/","title":"Excessive Nulls","text":""},{"location":"checks/excessive_nulls/#excessive-nulls","title":"Excessive Nulls","text":""},{"location":"checks/excessive_nulls/#description","title":"Description","text":"<p>This check identifies non-text fields with <code>null=True</code>. Allowing null values for non-text fields can lead to inconsistent data and complicate handling of missing values. It recommends removing <code>null=True</code> for fields where null values are not expected or necessary.</p>"},{"location":"checks/excessive_nulls/#rationale","title":"Rationale","text":"<p>Using <code>null=True</code> excessively for non-text fields can introduce unnecessary complexity when handling missing values. Ensuring that only fields that require null values have <code>null=True</code> can lead to cleaner data and simpler code.</p>"},{"location":"checks/excessive_nulls/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass MyModel(models.Model):\nstart_date = models.DateField(null=True)\n</code></pre> <p>The start_date field allows null values but might not need to. The check would detect this and recommend removing null=True if it's not necessary:</p> <pre><code>class MyModel(models.Model):\nstart_date = models.DateField()\n</code></pre> <p>By removing null=True for fields where it's not required, you can simplify handling missing values and ensure data consistency.</p>"},{"location":"checks/foreign_key_naming/","title":"Foreign Key Naming","text":""},{"location":"checks/foreign_key_naming/#foreignkey-naming","title":"ForeignKey Naming","text":""},{"location":"checks/foreign_key_naming/#description","title":"Description","text":"<p>This check ensures that the naming convention for <code>ForeignKey</code> fields in a Django model follows the format: <code>{related_model_name.lower()}_id</code>.</p>"},{"location":"checks/foreign_key_naming/#rationale","title":"Rationale","text":"<p>Following a consistent naming convention for <code>ForeignKey</code> fields improves code readability and maintainability. It makes it easier for developers to understand the relationships between models and work with the codebase.</p>"},{"location":"checks/foreign_key_naming/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass Author(models.Model):\nname = models.CharField(max_length=100)\nclass Book(models.Model):\ntitle = models.CharField(max_length=100)\nwriter = models.ForeignKey(Author, on_delete=models.CASCADE)\n</code></pre> <p>The writer field is a ForeignKey field, but its name does not follow the naming convention. The check would detect this and recommend changing the field name to author_id:</p> <pre><code>author_id = models.ForeignKey(Author, on_delete=models.CASCADE)\n</code></pre> <p>By following the naming convention, developers working with the code can easily understand the relationship between Book and Author models.</p>"},{"location":"checks/inappropriate_cascade/","title":"Inappropriate Cascade","text":""},{"location":"checks/inappropriate_cascade/#inappropriate-cascade","title":"Inappropriate Cascade","text":""},{"location":"checks/inappropriate_cascade/#description","title":"Description","text":"<p>This check ensures that the <code>CASCADE</code> option is not used inappropriately for the <code>on_delete</code> parameter in <code>ForeignKey</code> fields, as it can lead to unexpected data loss when a related object is deleted.</p>"},{"location":"checks/inappropriate_cascade/#rationale","title":"Rationale","text":"<p>Using <code>CASCADE</code> for the <code>on_delete</code> parameter in <code>ForeignKey</code> fields can result in the deletion of related objects when the referenced object is deleted. While this may be appropriate in some cases, other options like <code>SET_NULL</code> or <code>PROTECT</code> can be safer alternatives depending on the application's requirements.</p>"},{"location":"checks/inappropriate_cascade/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass Author(models.Model):\nname = models.CharField(max_length=100)\nclass Book(models.Model):\ntitle = models.CharField(max_length=100)\nauthor = models.ForeignKey(Author, on_delete=models.CASCADE)\n</code></pre> <p>The author field is a ForeignKey field and is using the CASCADE option for on_delete. The check would detect this and recommend considering alternative options:</p> <pre><code>author = models.ForeignKey(Author, on_delete=models.SET_NULL, null=True)\n# or\nauthor = models.ForeignKey(Author, on_delete=models.PROTECT)\n</code></pre> <p>Evaluate the impact of using CASCADE on your application's data integrity and choose the appropriate option based on your specific use case.</p>"},{"location":"checks/large_char_field/","title":"Large Char Field","text":""},{"location":"checks/large_char_field/#large-charfield","title":"Large CharField","text":""},{"location":"checks/large_char_field/#description","title":"Description","text":"<p>This check identifies <code>CharField</code> instances with a <code>max_length</code> value that exceeds a specified threshold (default: 255) and recommends using a <code>TextField</code> instead for storing long strings.</p>"},{"location":"checks/large_char_field/#rationale","title":"Rationale","text":"<p><code>TextField</code> is more efficient for storing and retrieving long text values. By using a <code>TextField</code> instead of a large <code>CharField</code>, you can improve performance and reduce the likelihood of reaching the maximum allowed length for a character field.</p>"},{"location":"checks/large_char_field/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass BlogPost(models.Model):\ntitle = models.CharField(max_length=100)\ncontent = models.CharField(max_length=5000)\n</code></pre> <p>The content field is a CharField with a max_length of 5000, which is considered large. The check would detect this and recommend using a TextField instead:</p> <pre><code>content = models.TextField()\n</code></pre> <p>By using a TextField for the content field, you can store longer text values more efficiently and avoid reaching the maximum allowed length for a character field.</p>"},{"location":"checks/min_max_validator/","title":"Min Max Validator","text":""},{"location":"checks/min_max_validator/#minmaxvalidator","title":"MinMaxValidator","text":""},{"location":"checks/min_max_validator/#description","title":"Description","text":"<p>This check verifies that <code>IntegerField</code> and <code>DecimalField</code> instances have both <code>MinValueValidator</code> and <code>MaxValueValidator</code> to ensure data consistency and prevent out-of-range values from being stored in the database.</p>"},{"location":"checks/min_max_validator/#rationale","title":"Rationale","text":"<p>Using <code>MinValueValidator</code> and <code>MaxValueValidator</code> for numeric fields helps maintain data integrity by enforcing minimum and maximum allowed values for the fields. This reduces the chance of storing out-of-range values and helps maintain a consistent data set.</p>"},{"location":"checks/min_max_validator/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass Product(models.Model):\nname = models.CharField(max_length=100)\nprice = models.DecimalField(max_digits=10, decimal_places=2)\n</code></pre> <p>The price field is a DecimalField without MinValueValidator and MaxValueValidator. The check would detect this and recommend adding the validators:</p> <pre><code>from django.core.validators import MinValueValidator, MaxValueValidator\nclass Product(models.Model):\nname = models.CharField(max_length=100)\nprice = models.DecimalField(\nmax_digits=10, decimal_places=2,\nvalidators=[MinValueValidator(0), MaxValueValidator(10000)]\n)\n</code></pre> <p>By using MinValueValidator and MaxValueValidator, you can ensure that the price field only accepts values within a specified range.</p>"},{"location":"checks/missing_default/","title":"Missing Default","text":""},{"location":"checks/missing_default/#missing-default","title":"Missing Default","text":""},{"location":"checks/missing_default/#description","title":"Description","text":"<p>This check identifies fields that do not have a default value and are not nullable. It recommends either providing a default value or allowing null values to prevent issues when creating new records.</p>"},{"location":"checks/missing_default/#rationale","title":"Rationale","text":"<p>Having a default value or allowing null values for a field can help prevent issues when creating new records. This makes it easier to handle cases where a value is not provided, ensuring that the application can continue to function smoothly.</p>"},{"location":"checks/missing_default/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass UserProfile(models.Model):\nuser = models.OneToOneField(User, on_delete=models.CASCADE)\nbio = models.TextField()\n</code></pre> <p>The bio field does not have a default value and is not nullable. The check would detect this and recommend adding a default value or allowing null values:</p> <pre><code>class UserProfile(models.Model):\nuser = models.OneToOneField(User, on_delete=models.CASCADE)\nbio = models.TextField(default='', null=True)\n</code></pre> <p>By providing a default value or allowing null values for the bio field, you can prevent issues when creating new UserProfile instances without a bio value.</p>"},{"location":"checks/missing_help_text/","title":"Missing Help Text","text":""},{"location":"checks/missing_help_text/#missing-help-text","title":"Missing Help Text","text":""},{"location":"checks/missing_help_text/#description","title":"Description","text":"<p>This check identifies fields that do not have <code>help_text</code> attribute set. It recommends adding <code>help_text</code> to provide a description of the field's purpose and improve user experience.</p>"},{"location":"checks/missing_help_text/#rationale","title":"Rationale","text":"<p>Help text provides additional context and guidance for users interacting with the field, such as in the Django admin interface or other forms. Adding <code>help_text</code> can improve user experience and reduce confusion.</p>"},{"location":"checks/missing_help_text/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass UserProfile(models.Model):\nuser = models.OneToOneField(User, on_delete=models.CASCADE)\nbio = models.TextField()\n</code></pre> <p>The bio field does not have help_text set. The check would detect this and recommend adding help_text:</p> <pre><code>class UserProfile(models.Model):\nuser = models.OneToOneField(User, on_delete=models.CASCADE)\nbio = models.TextField(help_text=\"A brief description of the user's background.\")\n</code></pre> <p>By adding help_text to the bio field, you can provide additional context and guidance for users interacting with the field.</p>"},{"location":"checks/nullable_unique_fields/","title":"Nullable Unique Field","text":""},{"location":"checks/nullable_unique_fields/#nullable-unique-fields","title":"Nullable Unique Fields","text":""},{"location":"checks/nullable_unique_fields/#description","title":"Description","text":"<p>This check identifies nullable unique fields in Django models. It suggests using a non-nullable unique field with a default value instead of allowing null values in unique fields.</p>"},{"location":"checks/nullable_unique_fields/#rationale","title":"Rationale","text":"<p>Nullable unique fields can cause unexpected issues when multiple records have null values. Using a non-nullable unique field with a default value can help maintain data consistency and prevent potential issues.</p>"},{"location":"checks/nullable_unique_fields/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass Product(models.Model):\nname = models.CharField(max_length=100, unique=True, null=True)\n</code></pre> <p>The name field is a nullable unique field. The check would detect this and recommend using a non-nullable unique field with a default value instead:</p> <pre><code>class Product(models.Model):\nname = models.CharField(max_length=100, unique=True, default=\"\")\n</code></pre> <p>By changing the name field to be non-nullable with a default value, you can prevent potential issues and maintain data consistency.</p>"},{"location":"checks/reserved_sql_keywords/","title":"Reserved SQL Keywords","text":""},{"location":"checks/reserved_sql_keywords/#reserved-sql-keywords","title":"Reserved SQL Keywords","text":""},{"location":"checks/reserved_sql_keywords/#description","title":"Description","text":"<p>This check identifies field names in Django models that use reserved SQL keywords. It suggests renaming the field to avoid potential issues with unexpected behavior or SQL syntax errors.</p>"},{"location":"checks/reserved_sql_keywords/#rationale","title":"Rationale","text":"<p>Using reserved SQL keywords as field names can lead to unexpected behavior or SQL syntax errors. By avoiding reserved keywords, you can prevent potential issues and maintain data consistency.</p>"},{"location":"checks/reserved_sql_keywords/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass Employee(models.Model):\nname = models.CharField(max_length=100)\nselect = models.CharField(max_length=100)\n</code></pre> <p>The select field is named after a reserved SQL keyword. The check would detect this and recommend renaming the field:</p> <pre><code>class Employee(models.Model):\nname = models.CharField(max_length=100)\nrole = models.CharField(max_length=100)\n</code></pre> <p>By renaming the field to role, you can prevent potential issues and maintain data consistency.</p>"},{"location":"checks/reverse_cascade/","title":"Reverse Cascade","text":""},{"location":"checks/reverse_cascade/#reverse-cascade","title":"Reverse Cascade","text":""},{"location":"checks/reverse_cascade/#description","title":"Description","text":"<p>This check identifies <code>ForeignKey</code> or <code>OneToOneField</code> instances with the <code>CASCADE</code> delete rule that do not allow null values. It recommends allowing null values or using a different delete rule to prevent unintended data loss when related records are deleted.</p>"},{"location":"checks/reverse_cascade/#rationale","title":"Rationale","text":"<p>Allowing null values in a <code>ForeignKey</code> or <code>OneToOneField</code> with the <code>CASCADE</code> delete rule helps prevent unintended data loss when related records are deleted. It ensures that when a related object is deleted, the field in the current object is set to <code>NULL</code> instead of causing the current object to be deleted as well.</p>"},{"location":"checks/reverse_cascade/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass Author(models.Model):\nname = models.CharField(max_length=100)\nclass Book(models.Model):\ntitle = models.CharField(max_length=100)\nauthor = models.ForeignKey(Author, on_delete=models.CASCADE)\n</code></pre> <p>The author field is a ForeignKey with the CASCADE delete rule and does not allow null values. The check would detect this and recommend allowing null values or using a different delete rule:</p> <pre><code>class Book(models.Model):\ntitle = models.CharField(max_length=100)\nauthor = models.ForeignKey(Author, on_delete=models.CASCADE, null=True)\n</code></pre> <p>By allowing null values for the author field or changing the delete rule, you can prevent unintended data loss when related records are deleted.</p>"},{"location":"checks/unbounded_auto_increment_pk/","title":"Unbounded Auto Increment","text":""},{"location":"checks/unbounded_auto_increment_pk/#unbounded-auto-increment-primary-key","title":"Unbounded Auto-Increment Primary Key","text":""},{"location":"checks/unbounded_auto_increment_pk/#description","title":"Description","text":"<p>This check identifies <code>IntegerField</code> primary key fields that are auto-incrementing and do not have a maximum length set. It recommends setting a maximum value for the field to prevent potential issues with running out of primary key values.</p>"},{"location":"checks/unbounded_auto_increment_pk/#rationale","title":"Rationale","text":"<p>Setting a maximum value for auto-incrementing primary keys helps ensure that you don't run into issues with running out of primary key values. This can prevent potential problems with data integrity and avoid unexpected behaviors in your application.</p>"},{"location":"checks/unbounded_auto_increment_pk/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass MyModel(models.Model):\nid = models.IntegerField(primary_key=True)\n</code></pre> <p>The id field is an auto-incrementing primary key without a maximum length set. The check would detect this and recommend setting a maximum value:</p> <pre><code>class MyModel(models.Model):\nid = models.IntegerField(primary_key=True, max_length=1000)\n</code></pre> <p>By setting a maximum value for the auto-incrementing primary key, you can prevent potential issues with running out of primary key values.</p>"},{"location":"checks/unique_without_index/","title":"Unique without Index","text":""},{"location":"checks/unique_without_index/#unique-without-index","title":"Unique Without Index","text":""},{"location":"checks/unique_without_index/#description","title":"Description","text":"<p>This check identifies fields that are marked as unique (<code>unique=True</code>) but do not have a database index (<code>db_index=False</code>). It recommends adding an index to the unique field to improve query performance.</p>"},{"location":"checks/unique_without_index/#rationale","title":"Rationale","text":"<p>Adding an index to a unique field can significantly speed up lookups for unique values, making queries more efficient. This improves the overall performance of your database and can help reduce query execution time.</p>"},{"location":"checks/unique_without_index/#example","title":"Example","text":"<p>Consider the following model:</p> <pre><code>from django.db import models\nclass MyModel(models.Model):\nname = models.CharField(max_length=100, unique=True)\n</code></pre> <p>The name field is marked as unique but does not have an index. The check would detect this and recommend adding an index:</p> <pre><code>class MyModel(models.Model):\nname = models.CharField(max_length=100, unique=True, db_index=True)\n</code></pre> <p>By adding an index to the unique field, you can improve the performance of queries involving this field.</p>"}]}